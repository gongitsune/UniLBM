#pragma kernel initialize
#pragma kernel collision
#pragma kernel advection

#define THREADS_X 4
#define THREADS_Y 4
#define THREADS_Z 4

#define Q 19

#include "Packages/jp.kosen-ac.uni-lbm/ShaderLibraly/lbm_utility.hlsl"

//==============================================================================
// 定数
//==============================================================================
// 各方向への速度ベクトル
static const int3 ei[Q] = {
    int3(+1, +0, +0), int3(-1, +0, +0), int3(+0, +0, +1), int3(+0, +0, -1), //  0 -  3
    int3(+0, -1, +0), int3(+0, +1, +0), int3(+1, +0, +1), int3(-1, +0, -1), //  4 -  7
    int3(-1, +0, +1), int3(+1, +0, -1), int3(+1, -1, +0), int3(-1, +1, +0), //  8 - 11
    int3(-1, -1, +0), int3(+1, +1, +0), int3(+0, -1, +1), int3(+0, +1, -1), // 12 - 15
    int3(+0, -1, -1), int3(+0, +1, +1), int3(+0, +0, +0) // 16 - 18
};
static const float s = 1.f / 18.f; // 隣接方向への重み
static const float l = 1.f / 36.f; // 対角方向への重み
static const float z = 1.f / 3.f; // 中心点での重み
// 各方向での重み
static const float w[Q] = {
    s, s, s, s,
    s, s, l, l,
    l, l, l, l,
    l, l, l, l,
    l, l, z
};
// バックバウンスする方向
static const uint inv[Q] = {
    1, 0, 3, 2,
    5, 4, 7, 6,
    9, 8, 11, 10,
    13, 12, 15, 14,
    17, 16, 18
};

//==============================================================================
// uniform 変数
//==============================================================================
// 1辺当たりシミュレーションセルサイズ
uint cell_size;
// 粘性係数
float tau;
// 周囲19格子への流出量
RWStructuredBuffer<float> f0;
RWStructuredBuffer<float> f1;
// フィールド
RWStructuredBuffer<uint> field;
// 粒子内の流速
RWStructuredBuffer<float3> velocity;
// 粒子の密度
RWStructuredBuffer<float> density;
// 外部入力速度
RWStructuredBuffer<float3> source_velocity;

//==============================================================================
// 格子ボルツマン法 (LBM: D3Q19) [STEP0: 初期化]
//==============================================================================
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void initialize(in uint3 id: SV_DispatchThreadID)
{
    if (any(id >= cell_size)) return;

    uint idx = get_index(id, cell_size);

    const float f_base = 10.5f;

    [unroll]
    for (int i = 0; i < Q; i++)
        f0[idx * Q + i] = f_base * w[i];
    velocity[idx] = float3(0, 0, 0);
    density[idx] = f_base;

    if (any(id == 0) || any(id == cell_size - 1))
        field[idx] = OUTFLOW_BOUNDARY_TYPE;
    else
        field[idx] = FLUID_TYPE;

    if (id.x == cell_size / 2 && id.y == cell_size / 2 && id.z == cell_size / 2)
        source_velocity[idx] = float3(0, 0.02f, 0);
    else
        source_velocity[idx] = float3(0, 0, 0);
}

//==============================================================================
// 格子ボルツマン法 (LBM: D3Q19) [STEP1: 衝突]
//==============================================================================
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void collision(in uint3 id: SV_DispatchThreadID)
{
    if (any(id >= cell_size)) return;

    int i;

    // ID
    uint idx = get_index(id, cell_size);

    // 各方向への流出量を計算
    float3 u = velocity[idx];
    float lo = density[idx];
    float u2 = dot(u, u);

    if (field[idx] == FLUID_TYPE)
        for (i = 0; i < Q; i++)
        {
            float a = dot(ei[i], u);
            float b = 3.f * a + 4.5f * a * a - 1.5f * u2;
            float c = lo * (1 + b);

            f0[idx * Q + i] -= (f0[idx * Q + i] - c * w[i]) / tau;
        }
    else
        for (i = 0; i < Q; i++)
            f0[idx * Q + i] = f0[idx * Q + inv[i]];
}

//==============================================================================
// 格子ボルツマン法 (LBM: D3Q19) [STEP2: 併進]
//==============================================================================
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void advection(in uint3 id: SV_DispatchThreadID)
{
    if (any(id >= cell_size)) return;

    int i;

    // ID
    uint idx = get_index(id, cell_size);

    // 各方向からの併進してくる量
    for (i = 0; i < Q; i++)
    {
        int3 neighbor = int3(id) - ei[i];
        if (any(neighbor < 0) || any(neighbor >= (int)cell_size))
        {
            f1[idx * Q + i] = w[i] * 10.5f;
            // density[idx] = 10.5f;
            // velocity[idx] = float3(0, 0, 0);
        }
        else
        {
            f1[idx * Q + i] = f0[get_index(neighbor, cell_size) * Q + i];
        }
    }

    // 現時刻の密度・速度ベクトルの産出
    float new_lo = 0.f;
    float3 new_u = 0.f;

    if (field[idx] == FLUID_TYPE)
    {
        for (i = 0; i < Q; i++)
        {
            new_lo += f1[idx * Q + i];
            new_u += f1[idx * Q + i] * ei[i];
        }
        if (new_lo > 0) new_u /= new_lo;

        // 入力速度を反映
        new_u += source_velocity[idx];
    }
    else
    {
        new_u = velocity[idx];
        new_lo = density[idx];
    }

    // 粒子の速度と密度を更新
    velocity[idx] = new_u;
    density[idx] = new_lo;
}
