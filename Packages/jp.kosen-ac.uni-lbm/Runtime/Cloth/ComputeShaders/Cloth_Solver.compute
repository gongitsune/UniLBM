#pragma kernel init
#pragma kernel simulation

#define NUM_THREADS 2
#define LIQUID_TYPE 0
#define BOUNDARY_TYPE 1

//==============================================================================
// Uniforms
//==============================================================================
// 前回の位置データ (読み込み用)
Texture2D pos_prev_buffer;
// 位置データ (読み込み用)
Texture2D pos_curr_buffer;
// 前回の位置データ (書き込み用)
RWTexture2D<float4> pos_prev_buffer_out;
// 位置データ (書き込み用)
RWTexture2D<float4> pos_curr_buffer_out;
// 法線データ (書き込み用)
RWTexture2D<float4> normal_buffer_out;

// LBMで計算されたセルごとの速度 (読み込み用)
StructuredBuffer<float3> lbm_velocity;
// LBMのセル解像度
int lbm_cell_res;
// LBMのセルの大きさ
float lbm_cell_size;
// LBMから受ける力の倍率
float lbm_force_scale;
// LBMセル上に布を置くときの変換行列
float4x4 lbm_transform;

// 布の解像度
int2 cloth_resolution;
// 布の総合的な長さ
float2 total_cloth_length;

// ばねの自然長
float rest_length;

// 重力
float3 gravity;
// 布の伸縮度合いを決定する定数
float stiffness;
// 布の速度の減衰率
float damp;
// 布の質量の逆数
float inv_mass;

// タイムステップ
float dt;

//==============================================================================
// Constants
//==============================================================================
// 近傍のパーティクルのIDオフセット (x, y) の配列
static const int2 directions[12] = {
    int2(-1, -1), //  0
    int2(0, -1), //  1
    int2(1, -1), //  2
    int2(1, 0), //  3
    int2(1, 1), //  4
    int2(0, 1), //  5
    int2(-1, 1), //  6
    int2(-1, 0), //  7
    int2(-2, -2), //  8
    int2(2, -2), //  9
    int2(2, 2), // 10
    int2(-2, 2) // 11
};

//==============================================================================
// 初期化カーネル
//==============================================================================
[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void init(in uint2 id: SV_DispatchThreadID)
{
    // 位置
    float3 pos = float3(id * rest_length, 0);
    pos.xy -= total_cloth_length * 0.5f;

    // 法線
    float3 normal = float3(0, 0, -1);

    // 書き込み
    pos_prev_buffer_out[id] = float4(pos, 1);
    pos_curr_buffer_out[id] = float4(pos, 1);
    normal_buffer_out[id] = float4(normal, 1);
}

//==============================================================================
// シミュレーションカーネル
//==============================================================================
[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void simulation(in uint2 id: SV_DispatchThreadID)
{
    // 位置を読み込み
    float3 pos = pos_curr_buffer[id].xyz;
    float3 pos_prev = pos_prev_buffer[id].xyz;

    // 速度を計算
    float3 vel = (pos - pos_prev) / dt;

    // 法線
    float3 normal = 0;
    // 法線計算時に使用する方向ベクトル
    float3 last_diff = 0;
    // 法線計算時に使用するイテレーション加算用
    float iter = 0;

    // パーティクルにかかる力、初期値として重力を代入
    float3 force = gravity;

    // 近傍のパーティクルにかかる力を計算
    float3 lbm_pos = mul(lbm_transform, float4(pos, 1)).xyz;
    uint3 lbm_id = uint3(lbm_pos / lbm_cell_size);
    [unroll]
    for (int x = -1; x <= 1; x++)
        [unroll]
        for (int y = -1; y <= 1; y++)
            [unroll]
            for (int z = -1; z <= 1; z++)
            {
                uint3 lbm_cell_id = lbm_id + uint3(x, y, z);
                if (any(lbm_cell_id >= (uint)lbm_cell_res))
                    continue;
                uint idx = lbm_cell_id.x + lbm_cell_id.y * lbm_cell_res + lbm_cell_id.z * lbm_cell_res * lbm_cell_res;
                float3 lbm_force = lbm_velocity[idx] * lbm_force_scale;
                force += clamp(lbm_force, -10, 10);
            }

    // 布の上辺は位置を固定するため計算を省く
    [flatten]
    if (id.y == (uint)(cloth_resolution.y - 1))
        return;

    // 近傍のパーティクルについて計算を行う
    [unroll]
    for (int k = 0; k < 12; k++)
    {
        int2 neighbor_id = id + directions[k];
        // 端のパーティクルについては計算しない
        [flatten]
        if (any(neighbor_id < 0) || any(neighbor_id >= cloth_resolution))
            continue;
        float3 neighbor_pos = pos_curr_buffer[neighbor_id].xyz;
        float3 pos_diff = neighbor_pos - pos;

        // 法線計算
        float3 curr_diff = normalize(pos_diff);
        if (iter > 0.f && k < 8)
        {
            float a = dot(curr_diff, last_diff);
            if (a > 0.f)
                normal += cross(last_diff, curr_diff);
        }
        last_diff = curr_diff;

        float neighbour_rest_length = length(directions[k] * rest_length);
        force += curr_diff * (length(pos_diff) - neighbour_rest_length) * stiffness - vel * damp;
        [flatten]
        if (k < 8)
            iter += 1.f;
    }

    // 法線ベクトルを計算
    normal = normalize(normal / -(iter - 1.f));

    // 加速度
    float3 acc = force * inv_mass;

    // ベレ法による位置計算
    float3 tmp = pos;
    pos = pos * 2.f - pos_prev + acc * (dt * dt);
    pos_prev = tmp;

    // 位置を書き込み
    pos_curr_buffer_out[id] = float4(pos, 1);
    pos_prev_buffer_out[id] = float4(pos_prev, 1);
    normal_buffer_out[id] = float4(normal, 1);
}
