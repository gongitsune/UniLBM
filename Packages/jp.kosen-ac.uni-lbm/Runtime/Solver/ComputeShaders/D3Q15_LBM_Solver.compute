#pragma kernel solve
#pragma kernel initialize

#define NUM_THREADS 2
#define Q 15

#include "Packages/jp.kosen-ac.uni-lbm/ShaderLibraly/lbm_utility.hlsl"

//==============================================================================
// Uniforms
//==============================================================================
RWStructuredBuffer<float> f0; // 前回の分布関数
RWStructuredBuffer<float> f1; // 今回の分布関数
RWStructuredBuffer<uint> field;
RWStructuredBuffer<float3> force_source;
RWStructuredBuffer<float3> velocity;

// 布に外部から力を与えるためのテクスチャ
RWTexture2D<float4> cloth_velocity;

int cell_size;
float3 force;
float tau;

//==============================================================================
// Constants
//==============================================================================
static const float l = 1.0f / 72.0f;
static const float s = 1.0f / 9.0f;
static const float z = 2.0f / 9.0f;

// 各方向への速度ベクトル
static const int3 e[Q] = {
    int3(0, 0, 0), int3(-1, 0, 0), int3(0, -1, 0), int3(0, 0, -1),
    int3(-1, -1, -1), int3(-1, -1, 1), int3(-1, 1, -1), int3(-1, 1, 1),
    int3(1, 0, 0), int3(0, 1, 0), int3(0, 0, 1),
    int3(1, 1, 1), int3(1, 1, -1), int3(1, -1, 1), int3(1, -1, -1)
};
// バックバウンスの方向
static const int inv[Q] = {0, 8, 9, 10, 11, 12, 13, 14, 1, 2, 3, 4, 5, 6, 7};
// 重み
static const float w[Q] = {
    z, s, s, s, l, l, l, l, s, s, s, l, l, l, l
};

//==============================================================================
// Functions
//==============================================================================
uint get_index(in uint3 pos)
{
    return pos.x + pos.y * cell_size + pos.z * cell_size * cell_size;
}

//==============================================================================
// LBM D3Q15 Solver
// REMARKS: 軽量化のために、本来衝突と併進を分けるべきところを一緒にしている
//==============================================================================
[numthreads(NUM_THREADS, NUM_THREADS, NUM_THREADS)]
void solve(uint3 id : SV_DispatchThreadID)
{
    int k;

    float omega = 1.0f / tau;
    uint idx = get_index(id);
    [flatten]
    if (any(id >= (uint)cell_size) || field[idx] != FLUID_TYPE)
        return;

    // 密度と速度の計算
    float rho = 0;
    float3 u = float3(0, 0, 0);

    [unroll]
    for (k = 0; k < Q; k++)
    {
        float f = f0[idx * Q + k];
        rho += f;
        u += f * e[k];
    }

    u /= rho;

    // 速度を保存
    velocity[idx] = u;

    // 外力の加算
    u += force_source[idx] * 0.5f;

    // 衝突と併進
    [unroll]
    for (k = 0; k < Q; k++)
    {
        int3 neighbor = (int3)id + e[k];
        uint idx_p = get_index(neighbor);

        float dot_product = dot(e[k], u);
        float new_f = (1 - omega) * f0[idx * Q + k] + omega * w[k] * rho *
            (1.0f - 1.5f * dot(u, u) + 3.0f * dot_product + 4.5f * dot_product * dot_product);

        uint field_type = field[idx_p];
        bool is_boundary = field_type != FLUID_TYPE;
        bool is_cloth_boundary = is_boundary && field_type != OUTFLOW_BOUNDARY_TYPE;

        // 布との衝突の場合
        uint cloth_x = (field_type & 0xFFFF0000) >> 16; // 上位16ビット
        uint cloth_y = field_type & 0x0000FFFF; // 下位16ビット

        uint2 cloth_pos = is_cloth_boundary ? uint2(cloth_x, cloth_y) : 0;
        cloth_velocity[cloth_pos] = is_cloth_boundary ? float4(u, 0) : 0;

        uint f1_idx = is_boundary
                          ? idx * Q + inv[k]
                          : idx_p * Q + k;
        // 不正な値は省いておく
        float f1_val = isinf(new_f) || isnan(new_f) ? w[k] : new_f;
        f1[f1_idx] = f1_val;
    }
}

[numthreads(NUM_THREADS, NUM_THREADS, NUM_THREADS)]
void initialize(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint)cell_size)) return;

    uint idx = get_index(id);

    [unroll]
    for (int k = 0; k < Q; k++)
        f0[idx * Q + k] = w[k];

    field[idx] = FLUID_TYPE;
    if (any(id == 0 || id == (uint)cell_size - 1))
        field[idx] = OUTFLOW_BOUNDARY_TYPE;

    if (id.x == (uint)cell_size / 2 && id.y == (uint)cell_size / 2 && id.z == (uint)cell_size / 2)
        force_source[idx] = force;
    else
        force_source[idx] = float3(0, 0, 0);
}
