#pragma kernel solve
#pragma kernel initialize

#define Q 15
#define FLUID_TYPE 0
#define BOUNDARY_TYPE 1

//==============================================================================
// Uniforms
//==============================================================================
RWStructuredBuffer<float> f0; // 前回の分布関数
RWStructuredBuffer<float> f1; // 今回の分布関数
RWStructuredBuffer<uint> field;
RWStructuredBuffer<float3> force_source;
RWStructuredBuffer<float3> velocity;

int cell_size;
float3 force;
float tau;

//==============================================================================
// Constants
//==============================================================================
static const float l = 1.0f / 72.0f;
static const float s = 1.0f / 9.0f;
static const float z = 2.0f / 9.0f;

// 各方向への速度ベクトル
static const int3 e[Q] = {
    int3(0, 0, 0), int3(-1, 0, 0), int3(0, -1, 0), int3(0, 0, -1),
    int3(-1, -1, -1), int3(-1, -1, 1), int3(-1, 1, -1), int3(-1, 1, 1),
    int3(1, 0, 0), int3(0, 1, 0), int3(0, 0, 1),
    int3(1, 1, 1), int3(1, 1, -1), int3(1, -1, 1), int3(1, -1, -1)
};
// バックバウンスの方向
static const int inv[Q] = {0, 8, 9, 10, 11, 12, 13, 14, 1, 2, 3, 4, 5, 6, 7};
// 重み
static const float w[Q] = {
    z, s, s, s, l, l, l, l, s, s, s, l, l, l, l
};

//==============================================================================
// Functions
//==============================================================================
uint get_index(in uint3 pos)
{
    return pos.x + pos.y * cell_size + pos.z * cell_size * cell_size;
}

uint3 periodic_boundary(in int3 pos)
{
    return (pos + cell_size) % cell_size;
}

//==============================================================================
// LBM D3Q15 Solver
//==============================================================================
[numthreads(8,8,8)]
void solve(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint)cell_size)) return;

    float omega = 1.0f / tau;
    uint idx = get_index(id);
    if (field[idx] != FLUID_TYPE) return;

    // Calculate density and velocity
    float rho = 0;
    float3 u = float3(0, 0, 0);

    for (int m = 0; m < Q; m++)
    {
        float f = f0[idx * Q + m];
        rho += f;
        u += f * e[m];
    }

    u /= rho;

    // Store velocity
    velocity[idx] = u;

    // Update velocity with force source
    u += force_source[idx] * 0.5f;

    // Collision and streaming
    for (int k = 0; k < Q; k++)
    {
        int3 neighbor = (int3)id + e[k];

        bool is_outside = any(neighbor < 0) || any(neighbor >= (int)cell_size);
        if (is_outside)
        {
            f1[idx * Q + k] = f0[idx * Q + k];
        }
        else
        {
            uint idx_p = get_index(neighbor);

            float dot_product = dot(e[k], u);
            float new_f = (1 - omega) * f0[idx * Q + k] + omega * w[k] * rho *
                (1.0f - 1.5f * dot(u, u) + 3.0f * dot_product + 4.5f * dot_product * dot_product);

            if (field[idx_p] == BOUNDARY_TYPE)
                f1[idx * Q + inv[k]] = new_f;
            else
                f1[idx_p * Q + k] = new_f;
        }
    }
}

[numthreads(8,8,8)]
void initialize(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint)cell_size)) return;

    uint idx = get_index(id);
    field[idx] = FLUID_TYPE;

    for (int k = 0; k < Q; k++)
    {
        f0[idx * Q + k] = w[k];
    }

    // put obstacles
    float3 center = cell_size * 0.5f;
    center.y = 50;
    float3 pos = float3(id);
    float3 diff = pos - center;
    float radius = 5.0f;
    if (dot(diff, diff) < radius * radius)
    {
        field[idx] = BOUNDARY_TYPE;
    }

    if (id.x == (uint)cell_size / 2 && id.y == 40 && id.z == (uint)cell_size / 2)
        force_source[idx] = force;
    // else if (id.x == (uint)cell_size / 2 && id.y == 60 && id.z == (uint)cell_size / 2)
    //     force_source[idx] = -force;
    else
        force_source[idx] = float3(0, 0, 0);
}
